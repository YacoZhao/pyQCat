

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>开发指南 &mdash; pyQCat 0.0.6 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
  <link rel="stylesheet" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
  <link rel="stylesheet" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/pyQCat.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="结构及数据流程" href="../dataset/index.html" />
    <link rel="prev" title="用户指南" href="../user/index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pyQCat
          

          
          </a>

          
            
            
              <div class="version">
                0.0.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../help.html">获取帮助</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">用户指南</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">开发指南</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">顶层接口</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#topexperiment">实验顶层接口TopExperiment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#topanalysis">实验结果分析顶层接口TopAnalysis</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id3">自定义实验</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">简单模板</a></li>
<li class="toctree-l3"><a class="reference internal" href="#run">run方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">生成实验结果存储路径</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">构造波形</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">施加波形</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">注册实验</a></li>
<li class="toctree-l3"><a class="reference internal" href="#analysis">绑定Analysis接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">绘制脉冲时序图</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">获取并分析数据</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">analysis方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">获取实验结果</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">拟合实验数据</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">绘制实验结果图</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">完整的实验模板</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">实验调用执行方法</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dataset/index.html">结构及数据流程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API 文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changes/index.html">版本记录</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pyQCat</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>开发指南</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>开发指南<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>这是针对希望维护/扩展pyQCat的开发人员的指南。当你希望自定义新的实验时，你同样可以使用<code class="docutils literal notranslate"><span class="pre">pyQCat</span></code>，我们提供丰富的接口足以让你实现全新的实验。</p>
<div class="section" id="id2">
<h2>顶层接口<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>pyQCat中提供了实验顶层接口和结果分析顶层接口供你调用，当你需要开发全新的实验时，建议你提前了解TopExperiment和TopAnalysis接口以及它的使用方式。</p>
<div class="section" id="topexperiment">
<h3>实验顶层接口TopExperiment<a class="headerlink" href="#topexperiment" title="永久链接至标题">¶</a></h3>
<p>pyQCat中所有的实验都可以继承<code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code>类实现通用的功能，它包括绑定设备初始参数、参数校验、施加波形、绘制波形等功能，详细内容可以参考<a class="reference external" href="../api/experiment/stubs/pyQCat.experiment.TopExperiment.html">API文档</a>。</p>
<p>如果你想要自定义一个完整的实验，你必须提前实例化下面一些对象：</p>
<ul class="simple">
<li><p><strong>inst：</strong> 设备对象<a class="reference external" href="../api/instrument/stubs/pyQCat.instrument.Instrument.html">Instrument</a>，封装了实验参数的设置方法，集成了各种数据交互操作。它帮助你完成脉冲信号的施加并接受量子比特返回的数据。</p></li>
<li><p><strong>qubits：</strong> 量子比特对象<a class="reference external" href="../api/qubit/stubs/pyQCat.qubit.Qubit.html">Qubit</a>，定义了量子比特的常见参数，自动化校准流程的核心对象。它支持多比特实验，只需要你以元组的形式传入比特对象即可。</p></li>
</ul>
<p>当然，通常比特测试实验需要更丰富的功能，我们为你提供了丰富的参数选项：</p>
<ul class="simple">
<li><p><strong>compensate:</strong> 波形校准对象<a class="reference external" href="../api/pulse/stubs/pyQCat.pulse.PulseCorrection.html">PulseCorrection</a>，用来进行校准波形。</p></li>
<li><p><strong>discriminator:</strong> IQ分类器对象<a class="reference external" href="../api/tool/stubs/pyQCat.tool.iqprobability.html">IQdiscriminator</a>，用来获取P0和P1的值 。</p></li>
<li><p><strong>correct_dc:</strong> 施加到比特上的电压。</p></li>
<li><p><strong>repeat:</strong> 实验重复次数。</p></li>
<li><p><strong>label:</strong> 用来自定义实验名称。</p></li>
<li><p><strong>schedule_type:</strong> 绘制脉冲时序图的类型，有<code class="docutils literal notranslate"><span class="pre">envelop</span></code>和<code class="docutils literal notranslate"><span class="pre">sequence</span></code>两种选择</p></li>
</ul>
<p>此外还支持多读取通道的实验，你可以通过<strong>multi_readout_channels</strong>属性传入多通道列表。</p>
</div>
<div class="section" id="topanalysis">
<h3>实验结果分析顶层接口TopAnalysis<a class="headerlink" href="#topanalysis" title="永久链接至标题">¶</a></h3>
<p>执行实验之后，我们提供了通用的实验结果分析类<code class="docutils literal notranslate"><span class="pre">TopAnalysis</span></code>，你可以继承它实现一些通用的功能，同时扩充一些你需要的功能，详细内容可见<a class="reference external" href="../api/experiment/stubs/pyQCat.experiment.TopAnalysis.html">API文档</a>，当你实现新的实验时，你可以继承 <code class="docutils literal notranslate"><span class="pre">TopAnalysis</span></code> 定义新实验的结果分析类来实现具体的结果分析操作。它的初始化需要下面的参数：</p>
<ul class="simple">
<li><p><strong>id_:</strong> TopExperiment对象的id属性，用来进行绑定实验。</p></li>
<li><p><strong>data_type (str):</strong> 数据类型，只能设置为 <code class="docutils literal notranslate"><span class="pre">amp-phase</span></code> 和 <code class="docutils literal notranslate"><span class="pre">I-Q</span></code></p></li>
<li><p><strong>discriminator：</strong> 如果你想接受<code class="docutils literal notranslate"><span class="pre">I-Q</span></code>数据，你必须将<code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code>中定义的<code class="docutils literal notranslate"><span class="pre">discriminator</span></code>传递给分析类</p></li>
<li><p><strong>is_dynamic(int):</strong> 是否启用动态绘图，默认为1，开启动态绘图</p></li>
<li><p><strong>file_sys:</strong> 连接实验结果存储文件类，默认从 <code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code> 对象的 <code class="docutils literal notranslate"><span class="pre">file</span></code> 属性中获取</p></li>
<li><p><strong>fidelity_matrix (np.ndarray):</strong> 保真度矩阵，用来校准测量结果。当你输出了 <strong>fidelity_matrix</strong>, 同时你需要传入 <strong>measure_qubits</strong> 来规定测量的比特</p></li>
</ul>
</div>
</div>
<div class="section" id="id3">
<h2>自定义实验<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<div class="section" id="id4">
<h3>简单模板<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>所以当你需要实现新的实验时，可以分别定义<code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code>和<code class="docutils literal notranslate"><span class="pre">TopAnalysis</span></code>搭建基础实验框架，一般会为每个单独的实验绑定一个独立的分析模块，结构如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyQCat.experiment</span> <span class="kn">import</span> <span class="n">TopExperiment</span><span class="p">,</span> <span class="n">TopAnalysis</span>

<span class="c1"># 定义新的实验</span>
<span class="k">class</span> <span class="nc">NewExperiment</span><span class="p">(</span><span class="n">TopExperiment</span><span class="p">):</span>

    <span class="c1"># 运行实验</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 绑定实验结果分析接口</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">=</span> <span class="n">NewExperimentAnalysis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">pass</span>

<span class="c1"># 定义新的实验结果分析类</span>
<span class="k">class</span> <span class="nc">NewExperimentAnalysis</span><span class="p">(</span><span class="n">TopAnalysis</span><span class="p">):</span>

    <span class="c1"># 实验结果分析</span>
    <span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>在新的实验中你需要关注<code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code>中<code class="docutils literal notranslate"><span class="pre">run()</span></code>方法和<code class="docutils literal notranslate"><span class="pre">TopAnalysis</span></code>中<code class="docutils literal notranslate"><span class="pre">analyze()</span></code>方法的实现逻辑。</p>
</div>
<div class="section" id="run">
<h3>run方法<a class="headerlink" href="#run" title="永久链接至标题">¶</a></h3>
<p>run方法中，你需要实现的逻辑有下面几点：</p>
<p>① 为实验生成结果存储路径，你只需要调用<code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code>中现有的方法<code class="docutils literal notranslate"><span class="pre">config_file_sys()</span></code>即可；</p>
<p>② 构造施加到比特上的脉冲信息，我们在 <a class="reference external" href="../api/pulse/index.html">pulse</a> 模块下面定义了常用波形的构造方法，可供你使用；</p>
<p>③ 施加生成的脉冲信息到指定比特上，你只需要调用<code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code>中现有的方法<code class="docutils literal notranslate"><span class="pre">play_pulse()</span></code>即可；</p>
<p>④ 注册实验，支持<code class="docutils literal notranslate"><span class="pre">amp_phase</span></code>和<code class="docutils literal notranslate"><span class="pre">I_Q</span></code>两种格式的数据形式，你只需要调用<code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code>中现有的方法<code class="docutils literal notranslate"><span class="pre">register()</span></code>即可；</p>
<p>⑤ 绑定自定义的实验结果分析类，用来处理数据，你可以去 <a class="reference external" href="../api/experiment/stubs/pyQCat.experiment.TopAnalysis.html">top_analysis</a> 模块寻找指南；</p>
<p>⑥ 绘制脉冲时序图，你只需要调用<code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code>中现有的方法<code class="docutils literal notranslate"><span class="pre">plot_schedule()</span></code>即可；</p>
<p>⑦ 循环执行实验，获取实验结果，你只需要调用<code class="docutils literal notranslate"><span class="pre">TopAnalysis</span></code>中现有的方法<code class="docutils literal notranslate"><span class="pre">excute_loop()</span></code>即可；</p>
<p>我们以<code class="docutils literal notranslate"><span class="pre">Ramsey</span></code>实验为例，来演示一下具体的逻辑：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay_list</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">fringe</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">zamp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">schedule_index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ramsey实验执行函数&quot;&quot;&quot;</span>
    <span class="c1"># ① 为实验生成结果存储路径，直接调用config_file_sys()即可，你可传入字符串类型name属性</span>
    <span class="k">if</span> <span class="n">zamp</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;zamp=</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">zamp</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="si">}</span><span class="s1">v&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;zamp=0v&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">config_file_sys</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    
    <span class="c1"># ② 获取施加到比特上的脉冲信息，一般有 XY 线和 Z 线，你需要自己实现</span>
    <span class="n">xy_pulse_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">delay_list</span><span class="p">,</span> <span class="n">fringe</span><span class="p">)</span>

    <span class="c1"># ③ 施加生成的脉冲信息到指定比特上，你可以直接调用play_pulse()方法将脉冲加到比特上</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">play_pulse</span><span class="p">(</span><span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">xy_pulse_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">zamp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">z_pulse_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">delay_list</span><span class="p">,</span> <span class="n">zamp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">play_pulse</span><span class="p">(</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">z_pulse_list</span><span class="p">)</span>

    <span class="c1"># ④ 注册实验，支持amp_phase和I_Q两种格式的数据形式；</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;I_Q&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;amp_phase&quot;</span>
	<span class="c1"># 直接调用父类的register()方法即可</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">data_type</span><span class="p">)</span>

    <span class="c1"># ⑤ 绑定自定义的实验结果分析类，用来处理数据；</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">=</span> <span class="n">RamseyAnalysis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">delay_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>

    <span class="c1"># ⑥ 自动调用父类 plot_schedule 方法绘制脉冲时序图</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">plot_schedule</span><span class="p">(</span><span class="n">xy_index</span><span class="o">=</span><span class="n">schedule_index</span><span class="p">)</span>

    <span class="c1"># ⑦ 获取并分析数据，调用 TopAnalysis 的 excute_loop 方法循环执行实验并接受数据</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">excute_loop</span><span class="p">()</span>
</pre></div>
</div>
<p>根据上述的逻辑，当你实现简单的单比特实验时，我们只需要做两件事，一个是实现构建波形的代码，另一个是绑定实验结果分析类，我们在后面的内容会给出更详细的解释。当然如果实验不需要给某条线施加脉冲，你可以忽略构造波形的操作。</p>
<p><strong>除此之外，你可以在run方法定义时，传入实验需要扫描的参数，如比特Ramsey实验扫描延时时间，Rabi实验扫描幅值等，这些扫描参数你都可以作为run()方法的参数传入。</strong></p>
</div>
<div class="section" id="id5">
<h3>生成实验结果存储路径<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>在实验运行的第一步，我们往往需要为实验生成结果存储路径，你只需要调用<code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code>中现有的方法<code class="docutils literal notranslate"><span class="pre">config_file_sys()</span></code>即可，它会为你生成一个进行文件操作的对象<a class="reference external" href="../api/tool/stubs/pyQCat.tool.savefile.html">SaveFile</a> ，方便你将实验结果存储到指定的路径。简单的一行代码如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperiment</span><span class="p">(</span><span class="n">TopExperiment</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;实验执行函数&quot;&quot;&quot;</span>
        <span class="c1"># ① 为实验生成结果存储路径，直接调用config_file_sys()即可，你可传入字符串类型name属性</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_file_sys</span><span class="p">()</span>
        
        <span class="c1"># ② 获取施加到比特上的脉冲信息，一般有 XY 线和 Z 线，你需要自己实验</span>
        <span class="c1"># ③ 施加生成的脉冲信息到指定比特上，你可以直接调用play_pulse()方法将脉冲加到比特</span>
        <span class="c1"># ④ 注册实验，支持``amp_phase``和``I_Q``两种格式的数据形式；</span>
        <span class="c1"># ⑤ 绑定自定义的实验结果分析类，用来处理数据；</span>
        <span class="c1"># ⑥ 自动调用父类 plot_schedule 方法绘制脉冲时序图</span>
        <span class="c1"># ⑦ 接受实验数据</span>
</pre></div>
</div>
<p>上面的方法会默认以 <code class="docutils literal notranslate"><span class="pre">类名</span> <span class="pre">+</span> <span class="pre">时间</span></code>生成结果存储路径，当然如果你想扩展路径名称，你可以提供 <code class="docutils literal notranslate"><span class="pre">name</span></code> 属性，它会在时间后面新增你想生成的名称；</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperiment</span><span class="p">(</span><span class="n">TopExperiment</span><span class="p">):</span>

    <span class="c1"># 运行实验</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_file_sys</span><span class="p">(</span><span class="s1">&#39;TowQubitRB&#39;</span><span class="p">)</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p><img alt="image-20210811161958772" src="../_images/image-20210811161958772.png" /></p>
</div>
<div class="section" id="id6">
<h3>构造波形<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p><strong>案例：</strong></p>
<p>我们以Rabi振荡实验构造波形方法为例，Rabi振荡实验可以通过扫描幅值找出XY线上脉冲的最优幅值，同时也可以扫描脉冲的宽度，来判断比特频率是否准确，他的实现逻辑中并不涉及Z线的波形，因此你只需要构造XY线上的波形，Z线上的波形我们默认为0。它的代码为：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_get_drive_pulse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sweep_list</span><span class="p">:</span> <span class="n">List</span><span class="p">):</span>
    <span class="c1"># get pulse</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">sweep_list</span><span class="p">:</span>
        <span class="c1"># 扫描幅值</span>
        <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;Xpi&quot;</span><span class="p">:</span>
            <span class="n">pulse</span> <span class="o">=</span> <span class="n">pi_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">)</span>
            <span class="n">pulse</span><span class="o">.</span><span class="n">amp</span> <span class="o">=</span> <span class="n">param</span>
        <span class="k">elif</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;Xpi/2&quot;</span><span class="p">:</span>
            <span class="n">pulse</span> <span class="o">=</span> <span class="n">half_pi_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">)</span>
            <span class="n">pulse</span><span class="o">.</span><span class="n">amp</span> <span class="o">=</span> <span class="n">param</span>
            <span class="c1"># pulse *= 2</span>
        <span class="c1"># 扫描带宽</span>
        <span class="k">elif</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;width&quot;</span><span class="p">:</span>
            <span class="n">pulse</span> <span class="o">=</span> <span class="n">pi_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">)</span>
            <span class="n">pulse</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">param</span>
            <span class="n">pulse</span><span class="o">.</span><span class="n">detune</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span>
        <span class="n">pulse</span><span class="o">.</span><span class="n">get_pulse</span><span class="p">()</span>
        <span class="k">yield</span> <span class="n">pulse</span>
</pre></div>
</div>
<p><strong>波形调用：</strong></p>
<p>构造波形一般你需要提供扫描参数，这些参数与波形生成有关，我们在 <a class="reference external" href="../api/pulse/index.html">Pulse模块</a> 提供了丰富的波形构造方式，你可以直接进行调用，我们定义了六种常用的波形类：</p>
<p><img alt="image-20210701172735473" src="file://C:/Users/Origin41515/AppData/Roaming/Typora/typora-user-images/image-20210701172735473.png?lastModify=1628664456" /></p>
<p>图中红色表示施加到Z线上的波形，绿色表示施加到XY线上的波形，黄色为读取线路波形。</p>
<p>此外，我们还对经常使用的波形进行了封装，他们波形可以从图中看出。</p>
<ul class="simple">
<li><p>pi_pulse: 比特反转波形</p></li>
<li><p>half_pi_pulse: 比特反转一半的波形</p></li>
<li><p>zero_pulse: 0波形</p></li>
</ul>
<p><img alt="image-20210811154029338" src="../_images/image-20210811154029338.png" /></p>
<p>对于<code class="docutils literal notranslate"><span class="pre">pi_pulse</span></code>、<code class="docutils literal notranslate"><span class="pre">half_pi_pulse</span></code>、<code class="docutils literal notranslate"><span class="pre">zero_pulse</span></code>波形，我们进行封装，你可以直接通过输入Qubit比特对象生成脉冲波形，如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pulse1</span> <span class="o">=</span> <span class="n">pi_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">)</span>
<span class="n">pulse2</span> <span class="o">=</span> <span class="n">half_pi_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">)</span>
<span class="n">pulse3</span> <span class="o">=</span> <span class="n">zero_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>生成波形数值序列：</strong></p>
<p>当你生成波形之后，你必须指定统一的方法 <code class="docutils literal notranslate"><span class="pre">get_pulse（）</span></code>方法，实现波形数值序列的计算，他会保存在脉冲的 <code class="docutils literal notranslate"><span class="pre">pulse</span></code> 属性中，如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pulse1</span> <span class="o">=</span> <span class="n">pi_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">)</span>

<span class="c1"># 生成数值序列</span>
<span class="n">pulse1</span><span class="o">.</span><span class="n">get_pulse</span><span class="p">()</span>

<span class="c1"># 获取波形数据</span>
<span class="n">pulse_data</span> <span class="o">=</span> <span class="n">pulse1</span><span class="o">.</span><span class="n">pulse</span>
</pre></div>
</div>
<p><strong>波形拼接：</strong></p>
<p>在pyQCat中波形拼接非常简单，你只需要将脉冲对象当成数字进行加法 <code class="docutils literal notranslate"><span class="pre">+</span></code> 或者乘法 <code class="docutils literal notranslate"><span class="pre">*</span></code> 操作即可，如SpinEcho实验中需要进行波形拼接，你完全可以这样操作:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">front_drag</span> <span class="o">=</span> <span class="n">half_pi_pulse</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="n">front_drag</span><span class="o">.</span><span class="n">get_pulse</span><span class="p">()</span>

<span class="n">front_delay</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">front_delay</span><span class="o">.</span><span class="n">get_pulse</span><span class="p">()</span>

<span class="n">mid_drag</span> <span class="o">=</span> <span class="n">pi_pulse</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="n">mid_drag</span><span class="o">.</span><span class="n">get_pulse</span><span class="p">()</span>

<span class="n">rear_delay</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">rear_delay</span><span class="o">.</span><span class="n">get_pulse</span><span class="p">()</span>

<span class="n">rear_drag</span> <span class="o">=</span> <span class="n">half_pi_pulse</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="n">rear_drag</span><span class="o">.</span><span class="n">get_pulse</span><span class="p">()</span>

<span class="n">final_pulse</span> <span class="o">=</span> <span class="n">front_drag</span> <span class="o">+</span> <span class="n">front_delay</span> <span class="o">+</span> <span class="n">mid_drag</span> <span class="o">+</span> <span class="n">rear_delay</span> <span class="o">+</span> <span class="n">rear_drag</span>
</pre></div>
</div>
<p>它会生成下面的波形：</p>
<p><img alt="image-20210811150455299" src="../_images/image-20210811150455299.png" /></p>
<p>当然乘法操作也是支持的，比如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pulse</span> <span class="o">=</span> <span class="n">pi_pulse</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="n">new_pulse</span> <span class="o">=</span> <span class="n">pulse</span> <span class="o">*</span> <span class="mi">12</span>
</pre></div>
</div>
<p>它会生成下面的波形：</p>
<p><img alt="image-20210811150115191" src="../_images/image-20210811150115191.png" /></p>
<p><strong>波形构造代码逻辑：</strong></p>
<p>上面已经介绍了波形构造的方法，你可以按照下面的结果生成你希望的波形</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperiment</span><span class="p">(</span><span class="n">TopExperiment</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;实验执行函数&quot;&quot;&quot;</span>
        <span class="c1"># ① 为实验生成结果存储路径，直接调用config_file_sys()即可，你可传入字符串类型name属性</span>
        
        <span class="c1"># ② 获取施加到比特上的脉冲信息，一般有 XY 线和 Z 线，你需要自己实现</span>
        <span class="n">xy_pulse_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">sweep_list</span><span class="p">)</span>
        <span class="n">z_pulse_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">sweep_list</span><span class="p">)</span>
        
        <span class="c1"># ③ 施加生成的脉冲信息到指定比特上，你可以直接调用play_pulse()方法将脉冲加到比特</span>
        <span class="c1"># ④ 注册实验，支持``amp_phase``和``I_Q``两种格式的数据形式；</span>
        <span class="c1"># ⑤ 绑定自定义的实验结果分析类，用来处理数据；</span>
        <span class="c1"># ⑥ 自动调用父类 plot_schedule 方法绘制脉冲时序图</span>
        <span class="c1"># ⑦ 接受实验数据</span>
        
    <span class="k">def</span> <span class="nf">get_xy_pulse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;获取 XY 线上的脉冲&quot;&quot;&quot;</span>
        <span class="o">...</span>
        
        <span class="n">pulse</span><span class="o">.</span><span class="n">get_pulse</span><span class="p">()</span>
        
        <span class="o">...</span>
        
        <span class="k">return</span> <span class="n">pulse_list</span>

    <span class="k">def</span> <span class="nf">get_z_pulse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;获取 Z 线上的脉冲&quot;&quot;&quot;</span>
        <span class="o">...</span>
        
        <span class="n">pulse</span><span class="o">.</span><span class="n">get_pulse</span><span class="p">()</span>
        
        <span class="o">...</span>
        
        <span class="k">return</span> <span class="n">pulse_list</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>施加波形<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>当波形构建完成之后，你可以直接调用封装好的方法 <code class="docutils literal notranslate"><span class="pre">play_pulse()</span></code> 进行波形施加，你只需要选择 <code class="docutils literal notranslate"><span class="pre">XY</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">Z</span></code> 决定脉冲施加的位置，当然你需要提供比特对象<code class="docutils literal notranslate"><span class="pre">qubit</span></code>和具体的脉冲信息<code class="docutils literal notranslate"><span class="pre">pulse</span></code>，就像下面的例子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperiment</span><span class="p">(</span><span class="n">TopExperiment</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;实验执行函数&quot;&quot;&quot;</span>
        <span class="c1"># ① 为实验生成结果存储路径，直接调用config_file_sys()即可，你可传入字符串类型name属性</span>
        <span class="c1"># ② 获取施加到比特上的脉冲信息，一般有 XY 线和 Z 线，你需要自己实验</span>
        
        <span class="c1"># ③ 施加生成的脉冲信息到指定比特上，你可以直接调用play_pulse()方法将脉冲加到比特</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">play_pulse</span><span class="p">(</span><span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">xy_pulse_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">play_pulse</span><span class="p">(</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">z_pulse_list</span><span class="p">)</span>
        
        <span class="c1"># ④ 注册实验，支持``amp_phase``和``I_Q``两种格式的数据形式；</span>
        <span class="c1"># ⑤ 绑定自定义的实验结果分析类，用来处理数据；</span>
        <span class="c1"># ⑥ 自动调用父类 plot_schedule 方法绘制脉冲时序图</span>
        <span class="c1"># ⑦ 接受实验数据</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>注册实验<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>注册实验是实验正常运行的关键，它实现了修正波形、注册波形、更新数据库映射等诸多操作。你不要关注它的具体逻辑，<strong>你只需要调用 <code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">register()</span></code>方法即可实现</strong>。</p>
<p>当然，你需要关注 <code class="docutils literal notranslate"><span class="pre">register()</span></code> 方法中的 <code class="docutils literal notranslate"><span class="pre">data_type</span></code> 属性， 他表示实验结果分析类型，可选择 <code class="docutils literal notranslate"><span class="pre">amp_phase</span></code> 或 <code class="docutils literal notranslate"><span class="pre">I_Q</span></code>, 默认为 <code class="docutils literal notranslate"><span class="pre">amp_phase</span></code> 类型。当选择 <code class="docutils literal notranslate"><span class="pre">amp_phase</span></code> 类型时，实验结果返回幅值和相位信息，且从设置的重复实验次数中取平均值返回； 当选择 <code class="docutils literal notranslate"><span class="pre">I_Q</span></code> 类型时，会根据 <code class="docutils literal notranslate"><span class="pre">IQ</span></code> 分类器对实验结果进行分析，形成当前比特处在0态的概率 <code class="docutils literal notranslate"><span class="pre">P0</span></code> 和处在1态的概率 <code class="docutils literal notranslate"><span class="pre">P1</span></code> 的形式返回结果，并且会返回与扫描参数相等规模的 <code class="docutils literal notranslate"><span class="pre">P0-P1</span></code> 数据。当你选择的注册类型为 <code class="docutils literal notranslate"><span class="pre">I-Q</span></code> 时，你必须提供 <a class="reference external" href="../api/tool/stubs/pyQCat.tool.iqprobability.html">IQdiscriminator</a>对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperiment</span><span class="p">(</span><span class="n">TopExperiment</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;实验执行函数&quot;&quot;&quot;</span>
        <span class="c1"># ① 为实验生成结果存储路径，直接调用config_file_sys()即可，你可传入字符串类型name属性</span>
        <span class="c1"># ② 获取施加到比特上的脉冲信息，一般有 XY 线和 Z 线，你需要自己实验</span>
        <span class="c1"># ③ 施加生成的脉冲信息到指定比特上，你可以直接调用play_pulse()方法将脉冲加到比特</span>
        
        <span class="c1"># ④ 注册实验，支持``amp_phase``和``I_Q``两种格式的数据形式；</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;I_Q&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">data_type</span><span class="p">)</span>
        
        <span class="c1"># ⑤ 绑定自定义的实验结果分析类，用来处理数据；</span>
        <span class="c1"># ⑥ 自动调用父类 plot_schedule 方法绘制脉冲时序图</span>
        <span class="c1"># ⑦ 接受实验数据</span>
</pre></div>
</div>
</div>
<div class="section" id="analysis">
<h3>绑定Analysis接口<a class="headerlink" href="#analysis" title="永久链接至标题">¶</a></h3>
<p>当波形构建完成并施加完成之后，你需要实现获取数据的功能，那么这个时候你需要为你的实验绑定 <code class="docutils literal notranslate"><span class="pre">TopAnalysis</span></code>，前面介绍过<code class="docutils literal notranslate"><span class="pre">TopAnalysis</span></code> 的初始化参数，你需要关注的属性有</p>
<ul class="simple">
<li><p><strong>id_:</strong> TopExperiment对象的id属性，用来进行绑定；</p></li>
<li><p><strong>data_type (str):</strong> 它决定了数据接受及呈现的方式；</p></li>
<li><p><strong>sweep_list (List):</strong> 实验扫描参数，一般作为数据处理的 <code class="docutils literal notranslate"><span class="pre">xdata</span></code>;</p></li>
<li><p><strong>discriminator：</strong> 当你选择 <code class="docutils literal notranslate"><span class="pre">I_Q</span></code> 数据类型时，必须提供 <code class="docutils literal notranslate"><span class="pre">IQ</span></code> 分类器；</p></li>
<li><p>**is_dynamic (int): **默认开启动态绘图，如果你想加快实验速度，你可设置为0，关闭动态绘图；</p></li>
<li><p><strong>file_sys:</strong> 刚才我们生成了结果存储路径，我们需要将它传递给实验结果分析类；</p></li>
</ul>
<p>因此，如果你想将实验中某些参数传给实验结果分析类，你可以自定义新的实验结果分析类，通过重定义<code class="docutils literal notranslate"><span class="pre">__init__</span></code>的方式扩展它的属性，然后按照自己的逻辑进行绑定，下面给出了将 <code class="docutils literal notranslate"><span class="pre">sweep_list</span></code> 扫描参数传递给实验结果分析类的案例，当然 <code class="docutils literal notranslate"><span class="pre">discriminator</span></code> 属性你可以选择传入的值为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p><strong>定义新的实验结果分析类：</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperimentAnalysis</span><span class="p">(</span><span class="n">TopAnalysis</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">experiment_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">sweep_list</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">:</span> <span class="n">IQdiscriminator</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">file_sys</span><span class="p">:</span> <span class="n">SaveFile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        
        <span class="c1"># 传递给TopAnalysis类</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">experiment_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">,</span> <span class="n">file_sys</span><span class="o">=</span><span class="n">file_sys</span><span class="p">)</span>
        
        <span class="c1"># sweep_list为当前实验独有属性，因此以这样的方式单独记录</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_list</span> <span class="o">=</span> <span class="n">sweep_list</span>
</pre></div>
</div>
<p><strong>实验类中<code class="docutils literal notranslate"><span class="pre">run()</span></code>方法的调用：</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperiment</span><span class="p">(</span><span class="n">TopExperiment</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;实验执行函数&quot;&quot;&quot;</span>
        <span class="c1"># ① 为实验生成结果存储路径，直接调用config_file_sys()即可，你可传入字符串类型name属性</span>
        <span class="c1"># ② 获取施加到比特上的脉冲信息，一般有 XY 线和 Z 线，你需要自己实验</span>
        <span class="c1"># ③ 施加生成的脉冲信息到指定比特上，你可以直接调用play_pulse()方法将脉冲加到比特</span>
        <span class="c1"># ④ 注册实验，支持``amp_phase``和``I_Q``两种格式的数据形式；</span>
        <span class="c1"># ⑤ 绑定自定义的实验结果分析类，用来处理数据；</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">=</span> <span class="n">NewExperimentAnalysis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span> <span class="n">sweep_list</span><span class="o">=</span><span class="n">sweep_list</span><span class="p">,</span> 
                                              <span class="n">discriminator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">,</span> <span class="n">file_sys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>

        <span class="c1"># ⑥ 自动调用父类 plot_schedule 方法绘制脉冲时序图</span>
        <span class="c1"># ⑦ 接受实验数据</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>绘制脉冲时序图<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>如果你想检查脉冲时序图是否绘制正确，你可以直接调用 <code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">plot_schedule()</span></code> 方法，它将帮助你生成输入脉冲图形，方便你进行波形检查，当然这个方法只是辅助你进行波形检查，如果你不想查看波形图，可以不需要调用此方法。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperiment</span><span class="p">(</span><span class="n">TopExperiment</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;实验执行函数&quot;&quot;&quot;</span>
        <span class="c1"># ① 为实验生成结果存储路径，直接调用config_file_sys()即可，你可传入字符串类型name属性</span>
        <span class="c1"># ② 获取施加到比特上的脉冲信息，一般有 XY 线和 Z 线，你需要自己实验</span>
        <span class="c1"># ③ 施加生成的脉冲信息到指定比特上，你可以直接调用play_pulse()方法将脉冲加到比特</span>
        <span class="c1"># ④ 注册实验，支持``amp_phase``和``I_Q``两种格式的数据形式；</span>
        <span class="c1"># ⑤ 绑定自定义的实验结果分析类，用来处理数据；</span>

        <span class="c1"># ⑥ 自动调用父类 plot_schedule 方法绘制脉冲时序图</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_schedule</span><span class="p">()</span>

        <span class="c1"># ⑦ 接受实验数据</span>
</pre></div>
</div>
<p>如Rabi实验中，我们可以用这个方法绘制脉冲时序图如下：</p>
<p><img alt="image-20210811165015371" src="../_images/image-20210811165015371.png" /></p>
</div>
<div class="section" id="id10">
<h3>获取并分析数据<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>当你绑定了实验结果分析类之后，你就可以使用 <code class="docutils literal notranslate"><span class="pre">TopAnalysis</span></code> 中的方法了，我们给数据接受和分析过程进行了封装，你只需要调用 <code class="docutils literal notranslate"><span class="pre">TopAnalysis</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">excute_loop()</span></code> 方法即调用数据接受和处理的逻辑。当然，它可以正常执行的前提是，你需要在你的 <code class="docutils literal notranslate"><span class="pre">NewExperimentAnalysis</span></code> 中定义 <code class="docutils literal notranslate"><span class="pre">analysis()</span></code> 方法，因为我们 <code class="docutils literal notranslate"><span class="pre">excute_loop()</span></code> 的实现逻辑中调用了 <code class="docutils literal notranslate"><span class="pre">analysis()</span></code> 方法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">excute_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">analyze_one</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;循环获取实验测量结果&quot;&quot;&quot;</span>
    
    <span class="o">...</span>
    
    <span class="c1"># 用户自定义的 analysis() 方法</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">analyze</span><span class="p">()</span>
</pre></div>
</div>
<p>而你的 <code class="docutils literal notranslate"><span class="pre">run()</span></code> 方法中只需在最终执行  <code class="docutils literal notranslate"><span class="pre">excute_loop()</span></code> 即可</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperiment</span><span class="p">(</span><span class="n">TopExperiment</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;实验执行函数&quot;&quot;&quot;</span>
        <span class="c1"># ① 为实验生成结果存储路径，直接调用config_file_sys()即可，你可传入字符串类型name属性</span>
        <span class="c1"># ② 获取施加到比特上的脉冲信息，一般有 XY 线和 Z 线，你需要自己实验</span>
        <span class="c1"># ③ 施加生成的脉冲信息到指定比特上，你可以直接调用play_pulse()方法将脉冲加到比特</span>
        <span class="c1"># ④ 注册实验，支持``amp_phase``和``I_Q``两种格式的数据形式；</span>
        <span class="c1"># ⑤ 绑定自定义的实验结果分析类，用来处理数据；</span>
        <span class="c1"># ⑥ 自动调用父类 plot_schedule 方法绘制脉冲时序图</span>

        <span class="c1"># ⑦ 接受实验数据</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">excute_loop</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>analysis方法<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>analysis方法中，我们以单比特实验为例，你需要实验的逻辑有下面几点：</p>
<p>① 获取实验数据，我们提供了 <code class="docutils literal notranslate"><span class="pre">single_qubit_usualness()</span></code> 方法让你直接获取数据，避免繁琐的数据转化工作;</p>
<p>② 拟合实验数据，数据拟合方法<strong>需要自己去实现</strong>，我们在 <a class="reference external" href="../api/tool/stubs/pyQCat.tool.formula.html">formula</a> 模块中定义了常用的拟合公式;</p>
<p>③ 绘制实验结果图需要根据不同的实验结果自定义，我们在 <a class="reference external" href="../api/tool/stubs/pyQCat.tool.plot_data.html">plot_data</a> 模板中定义了常用的图像绘制工具供你调用。</p>
<p>我们以幅值优化实验<code class="docutils literal notranslate"><span class="pre">AmpOptimize</span></code>的analysis为例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; `AmpOptimize` 实验结果分析方法&quot;&quot;&quot;</span>
    
    <span class="c1"># ① 获取实验数据</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">title0</span><span class="p">,</span> <span class="n">title1</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_qubit_usualness</span><span class="p">()</span>
    
    <span class="c1"># ② 拟合实验数据</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">popt1</span><span class="p">,</span> <span class="n">rmse1</span><span class="p">,</span> <span class="n">fit_y1</span> <span class="o">=</span> <span class="n">cosine_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
        <span class="n">index1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">fit_y1</span><span class="p">)</span>
        <span class="n">plot_y</span> <span class="o">=</span> <span class="n">y0</span>
        <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;amp&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">popt1</span><span class="p">,</span> <span class="n">rmse1</span><span class="p">,</span> <span class="n">fit_y1</span> <span class="o">=</span> <span class="n">cosine_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>
        <span class="n">index1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">fit_y1</span><span class="p">)</span>
        <span class="n">plot_y</span> <span class="o">=</span> <span class="n">y1</span>
        <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">ylabel</span> <span class="o">=</span> <span class="n">title1</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Xpi_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_list</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span>

    <span class="c1"># ③ 绘制实验结果图</span>
    <span class="n">f_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; theta = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">xlabel</span> <span class="o">=</span> <span class="s2">&quot;Amplitude&quot;</span>
    <span class="n">line_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;raw data&quot;</span><span class="p">,</span> <span class="s2">&quot;fit data&quot;</span><span class="p">]</span>
    <span class="n">plot_multiple</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">plot_y</span><span class="p">,</span> <span class="n">fit_y1</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="n">ylabel</span><span class="p">,</span> <span class="n">line_labes</span><span class="o">=</span><span class="n">line_labels</span><span class="p">,</span>
                  <span class="n">title</span><span class="o">=</span><span class="n">title1</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2"> Amp=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpi_opt</span><span class="si">:</span><span class="s2">.7f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpi_opt</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>获取实验结果<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>我们在 <code class="docutils literal notranslate"><span class="pre">TopAnalysis</span></code> 中提供了单比特实验通用的数据接受函数 <code class="docutils literal notranslate"><span class="pre">single_qubit_usualness()</span></code>， 它会自动对实验数据进行解析，如果你的 <code class="docutils literal notranslate"><span class="pre">discriminator</span></code> 属性为空，它会给你返回 <code class="docutils literal notranslate"><span class="pre">amp-phase</span></code> 数据，如果不为空，它会给你返回 <code class="docutils literal notranslate"><span class="pre">I-Q</span></code> 数据，同时它会给你自动生成标题 <code class="docutils literal notranslate"><span class="pre">title</span></code> 信息。如果你按照这种方式，在分析类定义的时候，你必须提前绑定扫描参数 <code class="docutils literal notranslate"><span class="pre">x_list</span></code> ，而你只需要这样编写代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperimentAnalysis</span><span class="p">(</span><span class="n">TopAnalysis</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">experiment_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">sweep_list</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">:</span> <span class="n">IQdiscriminator</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">file_sys</span><span class="p">:</span> <span class="n">SaveFile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">experiment_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">,</span> <span class="n">file_sys</span><span class="o">=</span><span class="n">file_sys</span><span class="p">)</span>

        <span class="c1"># 必须绑定扫描参数 sweep_list </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_list</span> <span class="o">=</span> <span class="n">sweep_list</span>

    <span class="c1"># 实验结果分析</span>
    <span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># ① 获取实验数据</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">title0</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_qubit_usualness</span><span class="p">()</span>
        
        <span class="c1"># ② 拟合实验数据</span>
        <span class="c1"># ③ 绘制实验结果图</span>
</pre></div>
</div>
<p>当然如果你不想用这种方式自动获取实验结果，你也可以自己编写获取数据的逻辑，就像下面这样：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># ① 获取实验数据</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y0_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P0</span>
        <span class="n">y1_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y0_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp</span>
        <span class="n">y1_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase</span>
        
    <span class="c1"># ② 拟合实验数据</span>
    <span class="c1"># ③ 绘制实验结果图</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h3>拟合实验数据<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>如果你的数据需要进行拟合，则需要你自己去实验拟合逻辑了，当然我们也提供的一些模板供你参考：</p>
<ul class="simple">
<li><p><a class="reference external" href="../api/tool/stubs/pyQCat.tool.formula.html">formula</a> 模块中定义了常用的拟合公式;</p></li>
<li><p><a class="reference external" href="../api/tool/stubs/pyQCat.tool.param_fit.html">param_fit</a> 模块中封装了常用的拟合方法；</p></li>
<li><p><a class="reference external" href="../api/tool/stubs/pyQCat.tool.smooth.html">smooth</a> 模块中封装smooth函数，让你对数据进行平滑处理；</p></li>
</ul>
<p>你可按照下面的模板来实验数据处理逻辑：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperimentAnalysis</span><span class="p">(</span><span class="n">TopAnalysis</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">experiment_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">sweep_list</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">:</span> <span class="n">IQdiscriminator</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">file_sys</span><span class="p">:</span> <span class="n">SaveFile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">experiment_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">,</span> <span class="n">file_sys</span><span class="o">=</span><span class="n">file_sys</span><span class="p">)</span>

        <span class="c1"># 必须绑定扫描参数 sweep_list </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_list</span> <span class="o">=</span> <span class="n">sweep_list</span>

    <span class="c1"># 实验结果分析</span>
    <span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># ① 获取实验数据</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">title0</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_qubit_usualness</span><span class="p">()</span>
        
        <span class="c1"># ② 拟合实验数据</span>
        <span class="n">fit_y0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
        <span class="n">fit_y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>
        
        <span class="c1"># ③ 绘制实验结果图</span>
        
    <span class="c1"># 拟合函数</span>
    <span class="k">def</span> <span class="nf">_fit_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3>绘制实验结果图<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>如果你需要绘制实验结果图，你可自行实现绘制图片的逻辑，当然我们也提供了一些绘图模板方法供你参考，你可以在<a class="reference external" href="../api/tool/stubs/pyQCat.tool.plot_data.html">plot_data</a>模块中寻找。</p>
<p>你可按照下面的模板来编写绘制实验结果的逻辑：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewExperimentAnalysis</span><span class="p">(</span><span class="n">TopAnalysis</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">experiment_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">sweep_list</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">:</span> <span class="n">IQdiscriminator</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">file_sys</span><span class="p">:</span> <span class="n">SaveFile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">experiment_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">,</span> <span class="n">file_sys</span><span class="o">=</span><span class="n">file_sys</span><span class="p">)</span>

        <span class="c1"># 必须绑定扫描参数 sweep_list </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_list</span> <span class="o">=</span> <span class="n">sweep_list</span>

    <span class="c1"># 实验结果分析</span>
    <span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># ① 获取实验数据</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">title0</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_qubit_usualness</span><span class="p">()</span>
        
        <span class="c1"># ② 拟合实验数据</span>
        <span class="n">fit_y0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
        <span class="n">fit_y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>
        
        <span class="c1"># ③ 绘制实验结果图</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fit_y0</span><span class="p">,</span> <span class="n">fit_y1</span><span class="p">)</span>
        
    <span class="c1"># 拟合函数</span>
    <span class="k">def</span> <span class="nf">_fit_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">pass</span>
    
   	<span class="c1"># 绘制结果图片</span>
    <span class="k">def</span> <span class="nf">_plot_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_y0</span><span class="p">,</span> <span class="n">fit_y1</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3>完整的实验模板<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>我们在上面完整的介绍了单比特实验实现的完整逻辑，模板总结如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyQCat.experiment</span> <span class="kn">import</span> <span class="n">TopExperiment</span><span class="p">,</span> <span class="n">TopAnalysis</span>
<span class="kn">from</span> <span class="nn">pyQCat.tool.iqprobability</span> <span class="kn">import</span> <span class="n">IQdiscriminator</span>
<span class="kn">from</span> <span class="nn">pyQCat.tool.savefile</span> <span class="kn">import</span> <span class="n">SaveFile</span>


<span class="k">class</span> <span class="nc">NewExperiment</span><span class="p">(</span><span class="n">TopExperiment</span><span class="p">):</span>

    <span class="c1"># 运行实验</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sweep_list</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">config_file_sys</span><span class="p">()</span>

        <span class="c1"># 获取波形，由用户自己实验</span>
        <span class="n">xy_pulse_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">sweep_list</span><span class="p">)</span>
        <span class="n">z_pulse_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_pulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">sweep_list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">play_pulse</span><span class="p">(</span><span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">xy_pulse_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">play_pulse</span><span class="p">(</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">,</span> <span class="n">z_pulse_list</span><span class="p">)</span>

        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;I_Q&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">data_type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">=</span> <span class="n">NewExperimentAnalysis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span> <span class="n">sweep_list</span><span class="o">=</span><span class="n">sweep_list</span><span class="p">,</span>
                                              <span class="n">discriminator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">,</span> <span class="n">file_sys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_schedule</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">excute_loop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_xy_pulse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;获取 XY 线上的脉冲&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">get_z_pulse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;获取 Z 线上的脉冲&quot;&quot;&quot;</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">NewExperimentAnalysis</span><span class="p">(</span><span class="n">TopAnalysis</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">experiment_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">sweep_list</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">:</span> <span class="n">IQdiscriminator</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">file_sys</span><span class="p">:</span> <span class="n">SaveFile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">experiment_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">,</span> <span class="n">file_sys</span><span class="o">=</span><span class="n">file_sys</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xdata</span> <span class="o">=</span> <span class="n">sweep_list</span>

    <span class="c1"># 实验结果分析</span>
    <span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">title0</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_qubit_usualness</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_analyze_data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polt_data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_analyze_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># 拟合数据，分析数据</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_polt_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># 绘制结果</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h3>实验调用执行方法<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>当你实现完整的实验之后，你只需要按照 <code class="docutils literal notranslate"><span class="pre">TopExperiment</span></code> 的构造方法，传入实验所需要的参数，如(inst、qubits、compensate、discriminator、correct_dc等)，创建实验对象，然后调用实验的<code class="docutils literal notranslate"><span class="pre">run()</span></code>方法即可启动实验，详细的实验调用及执行得到流程可以参考<a class="reference external" href="../user/index.html">用户指南</a>。</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../dataset/index.html" class="btn btn-neutral float-right" title="结构及数据流程" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="../user/index.html" class="btn btn-neutral float-left" title="用户指南" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2017-2021 inclusive, Origin Quantum Developer.
      <span class="lastupdated">
        最后更新于 2021/08/21.
      </span>

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>